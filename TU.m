%%Можно запускать секциями в editor -> run section
%% Построение матрицы управляемости
%меняем А и В под наши нужды
format rational
A = [1 0 2
    2 -2 3
    2 0 1] 

B = [0
    1
    1]

C = [B A*B A^2*B]
rg = rank(C)

%% Проверка стабилизируемости системы
%в S копируем полученную матрицу, заменяем не л.н. столбцы на л.н. столбцы
S = [0              2              0       
     1              1            0       
     1              1            1]

S_inv = inv(S)
 
A_volna = S_inv*A*S
B_volna = S_inv*B
%% проверка на стабилизируемость неуправляемой части 
%копировать неуправляемую часть матрицы
S_UnP= [3 1
    -17 -5];
p_UnP=poly(S_UnP);
r=roots(p_UnP)
%% Форма Фробениуса

p=poly(A)   %коэфициенты полинома (от старшей к младшей)
r=roots(p)  %спектр собственных чисел
%% 
A_volna_Frob =[0    1    0;
          0     0    1;
          3 -6 7]
B_volna_Frob = [0
           0
           1]
      
C_volna_Frob = [B_volna_Frob A_volna_Frob*B_volna_Frob A_volna_Frob^2*B_volna_Frob]
C_volna_Frob_inv = inv(C_volna_Frob)
C_inv=inv(C);
P_Frob=C_volna_Frob*C_inv;
%для проверки правильноси составления А_волна, чтобы вывело убрать ;
A_volna_Frob2=P_Frob*A*inv(P_Frob);

%% Качение через Фробениуса
C_volna_Frob
C_volna_Frob_inv
S_Frob=C*C_volna_Frob_inv
S_Frob_inv =inv(S_Frob)
%% ручками считаем Q_volna
Q_volna = [-9 -5 -13]
Q=Q_volna*S_Frob_inv

%% Через формулу Аккермана
C_inv = inv(C)
X_A=A^3+6*A^2+11*A+6*eye(3) %Характерестичесй полином от А. коэффициенты вбиваем, какие хотим получить по желаемому характерестическому полиному!
e=[0 0 1];
Q_A=-e*C_inv*X_A

%% Модальное управление, способ 1
%V - правые собственные вектора(можно упрощать до единичек или типо того, 
%ибо коэффициенты подбирает сам), D - соответвующие с.ч.)
[V,D] = eig(A)
%% чтобы упрощать было чуть легче
% нормировка конкретного столбца V так, чтобы значения были до 1 по модулю.
% дальше выражаем через минимальный элемент все остальные, чтобы получить
% вектор как нам удобно
N = normalize(V,'norm',1)

%% берем с.в., вставляем в Р
P = [1 1 0
    1 -1 1
    1 -1 0]
P_inv = inv(P)

A_domic = P_inv*A*P
B_domic = P_inv*B
%% ручками считаем tetha через матрицу замкнутой системы. A_c = A_domic + B_domic*Tetha_domic
Tetha_domic = [-12 0 0]
Tetha = Tetha_domic*P_inv
%% Модальное управление, способ 2. Находим левые с.в. конкретного числа, который хотим сдвинуть
A_trans = A'
[V,D] = eig(A_trans) 
% берем из V нужные нам с.в. Далее вставляем в P_inv транспонированные с.в. (чтобы было строкой) и дополняем до базиса
%% тут меняем число в V(:,*), где вместо * номер столбца с.в. в матрице V
N = normalize(V(:,1),'norm',1) 

%% вставляем найденные с.в., дополняем до базиса
P_inv=[1 0 1
    0 1 0
    1 0 0]
P=inv(P_inv)
%% 
A_cherta = P_inv*A*P
B_cherta = P_inv*B
%% стабильно считаем ручками через А_с
Tetha_cherta = [-6 0 0]
Tetha = Tetha_cherta*P_inv
