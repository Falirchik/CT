%%Можно запускать секциями в editor -> run section
%% Построение матрицы управляемости
%меняем А и В под наши нужды
format rational
A = [0 1 0
    0 0 1
    -2 3 0] 

B = [0
    0 
    1]

C = [B A*B A^2*B]
rg = rank(C)

%% Проверка стабилизируемости системы (разложение Калмана)
%в S копируем полученную матрицу, заменяем не л.н. столбцы на л.н. столбцы
S = [-1 1 0
    1 -2 0
    1 -1 1]

S_inv = inv(S)
 
A_volna = S_inv*A*S
B_volna = S_inv*B
%% проверка на стабилизируемость неуправляемой части 
%копировать неуправляемую часть матрицы
S_UnP= [3 1
    -17 -5];
p_UnP=poly(S_UnP);
r=roots(p_UnP)
%% Форма Фробениуса

p=poly(A)   %коэфициенты полинома (от старшей к младшей)
r=roots(p)  %спектр собственных чисел
%% 
A_volna_Frob =[0 1 0 0 0
            0 0 1 0 0
            0 0 0 1 0
            0 0 0 0 1
            2              1             -5              2/5            2]
B_volna_Frob = [0
                0
                0
                0
                1]
      
C_volna_Frob = [B_volna_Frob A_volna_Frob*B_volna_Frob A_volna_Frob^2*B_volna_Frob A_volna_Frob^3*B_volna_Frob A_volna_Frob^4*B_volna_Frob]
C_volna_Frob_inv = inv(C_volna_Frob)
C_inv=inv(C);
P_Frob=C_volna_Frob*C_inv;
%для проверки правильноси составления А_волна, чтобы вывело убрать ;
A_volna_Frob2=P_Frob*A*inv(P_Frob);

%% Качение через Фробениуса
C_volna_Frob
C_volna_Frob_inv
S_Frob=C*C_volna_Frob_inv
S_Frob_inv =inv(S_Frob)
%A_volna_c = A_volna_frob+B_volna_frob*Q_volna, где Q_volna = (Q_1, Q_2, Q_3), Q_i - какие-то числа, которые должны привести нас в желаемый спектр 
%по факту Q_i плюсуются к нижней строчке матрицы A_volna_frob, смотрим какие нам они нужны по значению (коэффициенты характеристического полинома при ЖЕЛАЕМОМ спектре)
%не забывать про смену знака в желаемом спектре! Мы тоже его приводит в вид
%Фробениуса!
%% ручками считаем Q_volna
Q_volna = [-75 -49 -10]
Q=Q_volna*S_Frob_inv

%% Через формулу Аккермана
C_inv = inv(C)
X_A=A^3+4*A^2+5*A+2*eye(3) %Характерестичесй полином от А. коэффициенты вбиваем, какие хотим получить по желаемому характерестическому полиному!
e=[0 0 1];
Q_A=-e*C_inv*X_A

%% Модальное управление, способ 1
%V - правые собственные вектора(можно упрощать до единичек или типо того, 
%ибо коэффициенты подбирает сам), D - соответвующие с.ч.)
[V,D] = eig(A)
%% чтобы упрощать было чуть легче
% нормировка конкретного столбца V так, чтобы значения были до 1 по модулю.
% дальше выражаем через минимальный элемент все остальные, чтобы получить
% вектор как нам удобно
N = normalize(V,'norm',1)

%% берем с.в., вставляем в Р (столбцами)
P = [1 0 1
    1 1 -2
    1 2 4]
P_inv = inv(P)

A_domic = P_inv*A*P
B_domic = P_inv*B
syms Q_1 Q_2 Q_3;
tetta_domic =[Q_1 Q_2 Q_3]
A_c=A_domic+B_domic*tetta_domic
%% ручками считаем tetha через матрицу замкнутой системы. A_c = A_domic + B_domic*Tetha_domic
Tetha_domic = [20 0 0]
Tetha = Tetha_domic*P_inv
%% Модальное управление, способ 2. Находим левые с.в. конкретного числа, который хотим сдвинуть
A_trans = A'
[V,D] = eig(A_trans) 

%% тут меняем число в V(:,*), где вместо * номер столбца с.в. в матрице V
N = normalize(V(:,5),'norm',1) 

% берем из V нужные нам с.в. Далее вставляем в P_inv транспонированные с.в. (чтобы было строкой) и дополняем до базиса
%% вставляем найденные с.в., дополняем до базиса
P_inv=[2 1 -1
    -1 -1 0
    0 1 0]
P=inv(P_inv)
%% 
A_cherta = P_inv*A*P
B_cherta = P_inv*B
tetta_cherta =[Q_1 Q_2 Q_3]
A_c=A_cherta+B_cherta*tetta_cherta
%% стабильно считаем ручками через А_с, где A_c=A_cherta+B_cherta*tetta_cherta
Tetha_cherta = [-6 0 0]
Tetha = Tetha_cherta*P_inv